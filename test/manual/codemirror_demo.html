<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeMirror + LiveText Demo</title>
    
    <!-- CodeMirror CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/codemirror.min.css">
    
    <!-- CodeMirror themes -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/monokai.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.16/theme/eclipse.min.css">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: #2c3e50;
            color: white;
            padding: 20px;
        }
        
        .header h1 {
            margin: 0;
            font-size: 24px;
        }
        
        .controls {
            background: #ecf0f1;
            padding: 15px;
            border-bottom: 1px solid #bdc3c7;
        }
        
        .control-group {
            display: inline-block;
            margin-right: 20px;
        }
        
        .control-group label {
            font-weight: bold;
            margin-right: 8px;
        }
        
        .control-group select, .control-group button {
            padding: 5px 10px;
            border: 1px solid #bdc3c7;
            border-radius: 4px;
            background: white;
        }

        .macro-toolbar {
            background: #f8f9fa;
            padding: 10px 15px;
            border-bottom: 1px solid #dee2e6;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .toolbar-label {
            font-weight: bold;
            color: #495057;
            margin-right: 10px;
        }

        .macro-btn {
            padding: 8px 12px;
            border: 1px solid #ced4da;
            border-radius: 4px;
            background: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.2s;
        }

        .macro-btn:hover {
            background: #e9ecef;
            border-color: #adb5bd;
            transform: translateY(-1px);
        }

        .macro-btn:active {
            transform: translateY(0);
            background: #dee2e6;
        }
        
        .editor-container {
            padding: 20px;
        }
        
        .CodeMirror {
            height: 500px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        
        /* LiveText syntax highlighting */
        .cm-strong { color: #e74c3c; font-weight: bold; }
        .cm-em { color: #8e44ad; font-style: italic; }
        .cm-string-2 { background: #f8f9fa; color: #495057; font-family: monospace; }
        .cm-strikethrough { color: #95a5a6; text-decoration: line-through; }
        .cm-variable { color: #3498db; font-weight: bold; }
        .cm-function { color: #27ae60; font-weight: bold; }
        .cm-keyword { color: #e67e22; font-weight: bold; }
        .cm-comment { color: #7f8c8d; font-style: italic; }
        .cm-bracket { color: #f39c12; font-weight: bold; }
        
        .info {
            background: #e8f4fd;
            border: 1px solid #bee5eb;
            border-radius: 4px;
            padding: 15px;
            margin: 20px;
        }
        
        .info h3 {
            margin-top: 0;
            color: #0c5460;
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px;
        }
        
        .feature {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
        }
        
        .feature h4 {
            margin-top: 0;
            color: #495057;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>CodeMirror + LiveText Demo</h1>
        </div>
        
        <div class="controls">
            <div class="control-group">
                <label>Theme:</label>
                <select id="theme-selector">
                    <option value="default">Default</option>
                    <option value="monokai">Monokai (Dark)</option>
                    <option value="eclipse">Eclipse</option>
                </select>
            </div>
            
            <div class="control-group">
                <label>Mode:</label>
                <select id="mode-selector">
                    <option value="livetext">LiveText</option>
                    <option value="markdown">Markdown</option>
                    <option value="html">HTML</option>
                    <option value="css">CSS</option>
                    <option value="javascript">JavaScript</option>
                </select>
            </div>
            
            <div class="control-group">
                <button id="toggle-linenumbers">Toggle Line Numbers</button>
            </div>
            
                                <div class="control-group">
                        <button id="toggle-wordwrap">Toggle Word Wrap</button>
                    </div>
                </div>

                <div class="macro-toolbar">
                    <span class="toolbar-label">Macros:</span>
                    <button onclick="runMacro('format_list')" title="Format as list" class="macro-btn">üìã</button>
                    <button onclick="runMacro('add_metadata')" title="Add metadata block" class="macro-btn">üìù</button>
                    <button onclick="runMacro('wrap_code')" title="Wrap in code block" class="macro-btn">üíª</button>
                    <button onclick="runMacro('bold_selection')" title="Make bold" class="macro-btn">**</button>
                    <button onclick="runMacro('italic_selection')" title="Make italic" class="macro-btn">__</button>
                    <button onclick="runMacro('code_selection')" title="Make code" class="macro-btn">``</button>
                </div>
        
        <div class="editor-container">
            <textarea id="editor" style="display: block; height: 500px; font-family: monospace; font-size: 14px; width: 100%; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
.h1 Sample LiveText Post

This is a sample LiveText post that demonstrates how CodeMirror could enhance the editing experience in Scriptorium.

.h3 Features Demonstrated

.list
*Syntax highlighting for LiveText syntax
**Line numbers for easy navigation  
`Multiple themes (light/dark)
~Word wrap toggle
**Search and replace (Ctrl+F/Cmd+F)
**Multiple editing modes
.end

.h3 Variables and Functions

The current user is $username and their role is $user.role. 
We can call $$max($count, 10) to get the maximum value.
Use $$link:https://scriptorium.dev for the main site.
Learn $$index[functional programming] today!

.h3 Dot Commands

.banner Welcome to Scriptorium!
.index web development
.comment This is a block comment that won't be processed
.end
    $.banner This is an indented banner command

.h3 Code and Formatting

This is `inline code and this is **bold text.
Here's some _italic content and ~~strikethrough text.

You can also use brackets for multi-word formatting:
*[This entire phrase is bold] and _[this entire phrase is italic].
For code: `[multiple words of code] and ~[strikethrough text].

For longer code blocks, we can use brackets:
`[def create_post(title, content)
  post = Post.new
  post.title = title
  post.content = content
  post.save
end]`

.h3 Lists and Structure

.list
**First item with *emphasis
`Second item with code
Third item with $variable reference
.end

.list
Numbered item with $$function call
Another item with _italic text
.end

.h3 Metadata

.list
**Author: $current_user
**Created: $$date
**Status: Draft
**Tags: demo, codemirror, livetext
.end

.h3 Content

This is the main content area where you would write your blog post. CodeMirror provides:

.list
**Better editing experience than basic textareas
*Syntax highlighting for LiveText syntax  
`Line numbers for easy reference
**Multiple themes for different preferences
**Keyboard shortcuts for power users
**Search and replace functionality
**Word wrap for long lines
**Multiple language modes for different content types
.end

The editor automatically handles indentation, provides visual feedback, and makes editing much more pleasant than a basic HTML textarea.

.comment This is a comment line that shows comment highlighting

.raw
This is raw content that won't be processed.
It can contain $variables and $$functions that won't expand.
It can even have .banner commands that won't execute.
Even .code ruby blocks are treated as plain text here.
__RAW__

.h3 Code Examples

.def
def create_post(title, content)
  post = Post.new
  post.title = title
  post.content = content
  post.save
end
.end

.code elixir
defmodule Post do
  def create(title, content) do
    %Post{title: title, content: content}
  end
end
.end

.code bash
#!/bin/bash
for file in *.lt3; do
  echo "Processing $file"
  ./process.sh "$file"
done
.end
            </textarea>
        </div>
        
        <div class="info">
            <h3>What You're Seeing</h3>
            <p>This is a standalone demo of CodeMirror integrated with LiveText-like content. It shows exactly what you'd get if you added CodeMirror to your Scriptorium web interface.</p>
        </div>
        
        <div class="features">
            <div class="feature">
                <h4>Immediate Benefits</h4>
                <ul>
                    <li>Better editing experience</li>
                    <li>Syntax highlighting</li>
                    <li>Line numbers</li>
                    <li>Multiple themes</li>
                </ul>
            </div>
            
            <div class="feature">
                <h4>Advanced Features</h4>
                <ul>
                    <li>Search & replace</li>
                    <li>Keyboard shortcuts</li>
                    <li>Word wrap</li>
                    <li>Multiple modes</li>
                </ul>
            </div>
            
            <div class="feature">
                <h4>Integration Points</h4>
                <ul>
                    <li>Post editing</li>
                    <li>Configuration editing</li>
                    <li>Template editing</li>
                    <li>Asset editing</li>
                </ul>
            </div>
        </div>
    </div>

    <script>
        // Custom LiveText syntax highlighting mode
        CodeMirror.defineMode("livetext", function() {
            return {
                startState: function() {
                    return {
                        inRaw: false,
                        inCodeBody: false,
                        codeLanguage: null,
                        inBracket: false,
                        bracketDepth: 0
                    };
                },
                
                token: function(stream, state) {
                    // Skip whitespace
                    if (stream.eatSpace()) return null;
                    
                    // Raw blocks override everything else
                    if (state.inRaw) {
                        if (stream.match(/^__RAW__/) || stream.match(/^\.end$/)) {
                            state.inRaw = false;
                            return "keyword";
                        }
                        stream.skipToEnd();
                        return "comment"; // Plain text in raw blocks
                    }
                    
                    // Check for .raw command
                    if (stream.match(/^\.raw$/)) {
                        state.inRaw = true;
                        return "keyword";
                    }
                    
                    // Check for .comment command
                    if (stream.match(/^\.comment$/)) {
                        state.inRaw = true; // Use same state as raw for plain text
                        return "keyword";
                    }
                    
                    // Code body blocks
                    if (state.inCodeBody) {
                        if (stream.match(/^\.end$/)) {
                            state.inCodeBody = false;
                            state.codeLanguage = null;
                            return "keyword";
                        }
                        
                        // Use appropriate language highlighting
                        if (state.codeLanguage === "ruby") {
                            // Ruby syntax highlighting
                            if (stream.match(/^#/)) {
                                stream.skipToEnd();
                                return "comment";
                            }
                            if (stream.match(/^def\b/)) return "def";
                            if (stream.match(/^end\b/)) return "keyword";
                            if (stream.match(/^class\b/)) return "def";
                            if (stream.match(/^module\b/)) return "def";
                            if (stream.match(/^require\b/)) return "keyword";
                            if (stream.match(/^puts\b/)) return "keyword";
                            if (stream.match(/^[A-Z][a-zA-Z0-9_]*/)) return "variable-2"; // Constants
                            if (stream.match(/^[a-z_][a-zA-Z0-9_]*/)) return "variable"; // Variables
                            if (stream.match(/^[0-9]+/)) return "number";
                            if (stream.match(/^["']/)) {
                                stream.skipTo(/["']/);
                                return "string";
                            }
                        } else if (state.codeLanguage === "elixir") {
                            // Elixir syntax highlighting
                            if (stream.match(/^#/)) {
                                stream.skipToEnd();
                                return "comment";
                            }
                            if (stream.match(/^def\b/)) return "def";
                            if (stream.match(/^end\b/)) return "keyword";
                            if (stream.match(/^defmodule\b/)) return "def";
                            if (stream.match(/^defp\b/)) return "def";
                            if (stream.match(/^IO\.puts\b/)) return "keyword";
                            if (stream.match(/^[A-Z][a-zA-Z0-9_]*/)) return "variable-2"; // Modules
                            if (stream.match(/^[a-z_][a-zA-Z0-9_]*/)) return "keyword"; // Functions
                            if (stream.match(/^[0-9]+/)) return "number";
                            if (stream.match(/^["']/)) {
                                stream.skipTo(/["']/);
                                return "string";
                            }
                        } else if (state.codeLanguage === "bash") {
                            // Bash syntax highlighting
                            if (stream.match(/^#/)) {
                                stream.skipToEnd();
                                return "comment";
                            }
                            if (stream.match(/^if\b/)) return "keyword";
                            if (stream.match(/^then\b/)) return "keyword";
                            if (stream.match(/^fi\b/)) return "keyword";
                            if (stream.match(/^for\b/)) return "keyword";
                            if (stream.match(/^do\b/)) return "keyword";
                            if (stream.match(/^done\b/)) return "keyword";
                            if (stream.match(/^\$[A-Z_]+/)) return "variable"; // Environment variables
                            if (stream.match(/^[0-9]+/)) return "number";
                            if (stream.match(/^["']/)) {
                                stream.skipTo(/["']/);
                                return "string";
                            }
                        }
                        
                        stream.next();
                        return null;
                    }
                    
                    // Check for code body commands
                    if (stream.match(/^\.(def|func)$/)) {
                        state.inCodeBody = true;
                        state.codeLanguage = "ruby";
                        return "keyword";
                    }
                    
                    let codeMatch = stream.match(/^\.code\s+(ruby|elixir|bash)/);
                    if (codeMatch) {
                        state.inCodeBody = true;
                        state.codeLanguage = codeMatch[1];
                        return "keyword";
                    }
                    
                    // One-line comments (. comment)
                    if (stream.match(/^\.\s/)) {
                        stream.skipToEnd();
                        return "comment";
                    }
                    
                    // Dot commands (.command or $.command)
                    if (stream.match(/^\.\w+/)) {
                        return "keyword";
                    }
                    if (stream.match(/^\s+\$\.[\w.]+/)) {
                        return "keyword";
                    }
                    
                    // Variables ($foo, $foo.bar) - stop at invalid characters
                    if (stream.match(/^\$/)) {
                        let name = "";
                        let ch = stream.next();
                        if (ch && /[a-zA-Z]/.test(ch)) {
                            name += ch;
                            while (stream.peek() && /[\w.]/.test(stream.peek())) {
                                ch = stream.next();
                                name += ch;
                            }
                            // Check if next character is invalid for a name
                            if (stream.peek() && !/[\w.]/.test(stream.peek())) {
                                return "variable";
                            }
                        }
                        return "variable";
                    }
                    
                    // Functions ($$foo, $$foo:param, $$foo[param])
                    if (stream.match(/^\$\$/)) {
                        let name = "";
                        let ch = stream.next();
                        if (ch && /[a-zA-Z]/.test(ch)) {
                            name += ch;
                            while (stream.peek() && /[\w.]/.test(stream.peek())) {
                                ch = stream.next();
                                name += ch;
                            }
                            // Check for colon parameter
                            if (stream.peek() === ":") {
                                stream.next();
                                stream.skipToEnd();
                            }
                            return "function";
                        }
                        return "function";
                    }
                    
                    // Bracketed content [content]
                    if (stream.match(/^\[/)) {
                        state.inBracket = true;
                        state.bracketDepth = 1;
                        return "bracket";
                    }
                    
                    if (state.inBracket) {
                        if (stream.match(/^\]/)) {
                            state.inBracket = false;
                            state.bracketDepth = 0;
                            return "bracket";
                        }
                        // Continue reading bracket content
                        stream.next();
                        return "string";
                    }
                    
                    // Bracketed formatting: *[text] _[text] `[text] ~[text]
                    if (stream.match(/^(\*|_|`|~)\[/)) {
                        state.inBracket = true;
                        state.bracketDepth = 1;
                        return "strong"; // All bracketed content gets same treatment for now
                    }
                    
                    // Markers (* _ ` ~) - single and doubled
                    // Note: LiveText markers only initiate, never terminate
                    if (stream.match(/^\*\*/)) {
                        // Doubled marker - read until space, comma, or period
                        stream.eatWhile(/[^\s,.]/);
                        return "strong";
                    }
                    if (stream.match(/^__/)) {
                        stream.eatWhile(/[^\s,.]/);
                        return "em";
                    }
                    if (stream.match(/^``/)) {
                        stream.eatWhile(/[^\s,.]/);
                        return "string-2";
                    }
                    if (stream.match(/^~~/)) {
                        stream.eatWhile(/[^\s,.]/);
                        return "strikethrough";
                    }
                    
                    // Single markers
                    if (stream.match(/^\*/)) {
                        stream.eatWhile(/[^\s]/);
                        return "strong";
                    }
                    if (stream.match(/^_/)) {
                        stream.eatWhile(/[^\s]/);
                        return "em";
                    }
                    if (stream.match(/^`/)) {
                        stream.eatWhile(/[^\s]/);
                        return "string-2";
                    }
                    if (stream.match(/^~/)) {
                        stream.eatWhile(/[^\s]/);
                        return "strikethrough";
                    }
                    
                    // Continue reading
                    stream.next();
                    return null;
                }
            };
        });

        // Initialize CodeMirror
        let editor;
        try {
            editor = CodeMirror.fromTextArea(document.getElementById('editor'), {
                mode: 'livetext',  // Use our custom LiveText mode
                theme: 'default',
                lineNumbers: true,
                lineWrapping: false,
                indentUnit: 2,
                tabSize: 2,
                indentWithTabs: false,
                scrollbarStyle: 'native',
                viewportMargin: Infinity,
                extraKeys: {
                    "Ctrl-S": function(cm) {
                        // Simulate save
                        console.log("Save triggered");
                    },
                    "Cmd-S": function(cm) {
                        // Simulate save on Mac
                        console.log("Save triggered");
                    }
                }
            });
            console.log("CodeMirror initialized successfully");
            // Hide the original textarea since CodeMirror is now handling it
            document.getElementById('editor').style.display = 'none';
        } catch (error) {
            console.error("CodeMirror initialization failed:", error);
            // Fallback: show the textarea content
            document.getElementById('editor').style.display = 'block';
            document.getElementById('editor').style.height = '500px';
            document.getElementById('editor').style.fontFamily = 'monospace';
            document.getElementById('editor').style.fontSize = '14px';
        }

        // Theme selector
        document.getElementById('theme-selector').addEventListener('change', function() {
            console.log('Theme changed to:', this.value);
            editor.setOption('theme', this.value);
        });

        // Mode selector
        document.getElementById('mode-selector').addEventListener('change', function() {
            let mode = this.value;
            console.log('Mode changed to:', mode);
            editor.setOption('mode', mode);
        });

        // Toggle line numbers
        document.getElementById('toggle-linenumbers').addEventListener('click', function() {
            let current = editor.getOption('lineNumbers');
            console.log('Line numbers:', current, '->', !current);
            editor.setOption('lineNumbers', !current);
        });

        // Toggle word wrap
        document.getElementById('toggle-wordwrap').addEventListener('click', function() {
            let current = editor.getOption('lineWrapping');
            console.log('Word wrap:', current, '->', !current);
            editor.setOption('lineWrapping', !current);
        });

        // Set initial size
        editor.setSize('100%', '500px');
        
        // Macro system
        const macros = {
            format_list: function(editor) {
                const selection = editor.getSelection();
                if (selection) {
                    const lines = selection.split('\n').filter(line => line.trim());
                    const formatted = lines.map(line => `*${line.trim()}`).join('\n');
                    editor.replaceSelection(formatted);
                } else {
                    // If no selection, format current line
                    const line = editor.getLine(editor.getCursor().line);
                    if (line.trim()) {
                        editor.replaceRange(`*${line.trim()}`, 
                            {line: editor.getCursor().line, ch: 0},
                            {line: editor.getCursor().line, ch: line.length});
                    }
                }
            },

            add_metadata: function(editor) {
                const metadata = `.metadata\n**Author: $username\n**Date: $$date\n**Status: Draft\n**Tags: \n.end`;
                editor.replaceSelection(metadata);
            },

            wrap_code: function(editor) {
                const selection = editor.getSelection();
                if (selection) {
                    editor.replaceSelection(`\`[${selection}]`);
                } else {
                    // If no selection, wrap current word
                    const cursor = editor.getCursor();
                    const word = editor.findWordAt(cursor);
                    if (word) {
                        const text = editor.getRange(word.anchor, word.head);
                        editor.replaceRange(`\`[${text}]`, word.anchor, word.head);
                    }
                }
            },

            bold_selection: function(editor) {
                const selection = editor.getSelection();
                if (selection) {
                    editor.replaceSelection(`*[${selection}]`);
                } else {
                    const cursor = editor.getCursor();
                    const word = editor.findWordAt(cursor);
                    if (word) {
                        const text = editor.getRange(word.anchor, word.head);
                        editor.replaceRange(`*[${text}]`, word.anchor, word.head);
                    }
                }
            },

            italic_selection: function(editor) {
                const selection = editor.getSelection();
                if (selection) {
                    editor.replaceSelection(`_[${selection}]`);
                } else {
                    const cursor = editor.getCursor();
                    const word = editor.findWordAt(cursor);
                    if (word) {
                        const text = editor.getRange(word.anchor, word.head);
                        editor.replaceRange(`_[${text}]`, word.anchor, word.head);
                    }
                }
            },

            code_selection: function(editor) {
                const selection = editor.getSelection();
                if (selection) {
                    editor.replaceSelection(`\`[${selection}]`);
                } else {
                    const cursor = editor.getCursor();
                    const word = editor.findWordAt(cursor);
                    if (word) {
                        const text = editor.getRange(word.anchor, word.head);
                        editor.replaceRange(`\`[${text}]`, word.anchor, word.head);
                    }
                }
            }
        };

        function runMacro(macroName) {
            const macro = macros[macroName];
            if (macro) {
                macro(editor);
                editor.focus(); // Return focus to editor
            }
        }

        // Focus the editor
        editor.focus();
                </script>
            </body>
            </html>
