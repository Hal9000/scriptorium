#!/Users/Hal/.rbenv/versions/3.2.3/bin/ruby

require_relative "../lib/scriptorium"
require 'readline'

# Main entry point for Scriptorium TUI
class ScriptoriumTUI
  include Scriptorium::Exceptions
  include Scriptorium::Helpers

  def initialize
    @api = Scriptorium::API.new(testmode: true)
    @testing = false
    @log_file = "scriptorium.log"
    setup_readline
  end

  def log(message)
    timestamp = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    File.open(@log_file, "a") do |f|
      f.puts "[#{timestamp}] #{message}"
    end
  end

  def discover_repo
    if Dir.exist?("test/scriptorium-TEST")
      puts "Found existing test repository: scriptorium-TEST"
      @testing = "test/scriptorium-TEST"
      @repo = Scriptorium::Repo.open("test/scriptorium-TEST")
      puts "Loaded test repository"
      return true
    elsif Dir.exist?("scriptorium-TEST")
      puts "Found existing test repository: scriptorium-TEST"
      @testing = "scriptorium-TEST"
      @repo = Scriptorium::Repo.open("scriptorium-TEST")
      puts "Loaded test repository"
      return true
    # elsif Dir.exist?(".scriptorium")
    # puts "Found existing repository: .scriptorium"
    #  home = ENV['HOME']
    #  @repo = Scriptorium::Repo.open("#{home}/.scriptorium")
    #  puts "Loaded test repository"
    else
      puts "No repository found."
      return false
    end
  end

  def create_new_repo
    puts "Creating new repository..."
    @testing = "test/scriptorium-TEST"
    @repo = Scriptorium::Repo.create("test/scriptorium-TEST", testmode: true)
    puts "Created repository successfully."
    
    # Run initial setup (like Runeblog)
    get_started
  end

  def wizard_first_view    
    log("WIZARD: Starting wizard_first_view")
    puts "[WIZARD] Starting wizard_first_view"
    # Check if this is the first view (only sample view exists)
    if @repo.views.length == 1 && @repo.views[0].name == "sample"
      log("WIZARD: Only sample view exists, proceeding with setup")
      puts "[WIZARD] Only sample view exists, proceeding with setup"
      puts "Let's set up your first view!"
      
      # Create a new view using existing interactive method
      log("WIZARD: Calling create_view to create new view")
      puts "[WIZARD] Calling create_view to create new view"
      create_view("view")
      
      # Get the current view name (the one we just created)
      current_view = @repo.current_view
      return unless current_view
      name = current_view.name
      log("WIZARD: Created view: #{name}")
      puts "[WIZARD] Created view: #{name}"
      
      # Ask about layout
      puts
      puts "[WIZARD] Asking about layout editing"
      if yesno("Would you like to edit the layout?")
        puts "[WIZARD] User chose to edit layout"
        edit_file("#{@repo.root}/views/#{name}/config/layout.txt")
      else
        puts "[WIZARD] User chose not to edit layout"
      end
      
      # Read the layout to see what containers we have
      layout_file = "#{@repo.root}/views/#{name}/config/layout.txt"
      puts "[WIZARD] Reading layout file: #{layout_file}"
      layout_content = read_file(layout_file)
      file_containers = layout_content.lines.map { |line| line.split(/\s+/).first }.compact
      puts "[WIZARD] Found containers in file: #{file_containers.join(', ')}"
      
      # Define logical order for containers
      logical_order = ['header', 'main', 'left', 'right', 'footer']
      
      # Use logical order, but only include containers that exist in the file
      containers = logical_order.select { |container| file_containers.include?(container) }
      puts "[WIZARD] Containers in logical order: #{containers.join(', ')}"
      
      # Configure each container
      containers.each do |container|
        puts
        puts "[WIZARD] Configuring container: #{container}"
        if yesno("Would you like to configure #{container}?")
          case container
          when 'header'
            puts "[WIZARD] Configuring header container"
            # This is complex and will be expanded later
            edit_file("#{@repo.root}/views/#{name}/config/header.txt")
          when 'main'
            puts "[WIZARD] Configuring main container (stub)"
            puts "Main container is just a stub for now"
          when 'left', 'right'
            puts "[WIZARD] Configuring sidebar container: #{container}"
            configure_sidebar_widgets(name, container)
          when 'footer'
            puts "[WIZARD] Configuring footer container (stub)"
            puts "Footer has no real config for now"
          end
        end
      end
      
      puts
      puts "[WIZARD] View setup complete!"
      puts "View setup complete!"
    else
      puts "[WIZARD] Wizard is only available for the first view setup"
      puts "Wizard is only available for the first view setup"
    end
  end

  def configure_sidebar_widgets(view_name, container)
    puts "[WIZARD] Starting configure_sidebar_widgets for #{container}"
    puts "Add widgets to #{container}? (y/n)"
    return unless yesno("Add widgets to #{container}?")
    
    # Show available widgets
    api = Scriptorium::API.new(@repo.root)
    available_widgets = api.widgets_available
    puts "[WIZARD] Available widgets: #{available_widgets.join(', ')}"
    puts "Available widgets: #{available_widgets.join(', ')}"
    
    selected_widgets = []
    available_widgets.each do |widget|
      puts "[WIZARD] Asking about widget: #{widget}"
      if yesno("Add #{widget} widget?")
        puts "[WIZARD] User selected widget: #{widget}"
        selected_widgets << widget
      else
        puts "[WIZARD] User skipped widget: #{widget}"
      end
    end
    
    # Configure each selected widget
    selected_widgets.each do |widget|
      puts "[WIZARD] Configuring widget: #{widget}"
      if yesno("Configure #{widget} widget?")
        case widget
        when 'links'
          puts "[WIZARD] Configuring links widget"
          edit_file("#{@repo.root}/views/#{view_name}/widgets/links/list.txt")
        when 'pages'
          puts "[WIZARD] Configuring pages widget"
          configure_pages_widget(view_name)
        end
      end
    end
  end

  def configure_pages_widget(view_name)
    puts "[WIZARD] Starting configure_pages_widget for #{view_name}"
    list_file = "#{@repo.root}/views/#{view_name}/widgets/pages/list.txt"
    puts "[WIZARD] Editing pages list file: #{list_file}"
    edit_file(list_file)
    
    # Check for missing pages
    pages_list = read_file(list_file, lines: true, chomp: true)
    puts "[WIZARD] Pages in list: #{pages_list.join(', ')}"
    missing_pages = []
    
    pages_list.each do |page|
      page_file = "#{@repo.root}/views/#{view_name}/pages/#{page}.html"
      if File.exist?(page_file)
        puts "[WIZARD] Page exists: #{page}"
      else
        puts "[WIZARD] Page missing: #{page}"
        missing_pages << page
      end
    end
    
    if missing_pages.any?
      puts
      puts "[WIZARD] Found #{missing_pages.length} missing pages: #{missing_pages.join(', ')}"
      if yesno("Do you want to edit the missing pages?")
        puts "[WIZARD] User chose to edit missing pages"
        missing_pages.each do |page|
          puts "[WIZARD] Asking about editing page: #{page}"
          if yesno("Edit #{page}?")
            puts "[WIZARD] User chose to edit page: #{page}"
            edit_file("#{@repo.root}/views/#{view_name}/pages/#{page}.html")
          else
            puts "[WIZARD] User chose to create empty file for page: #{page}"
            # Create empty .lt3 file
            write_file("#{@repo.root}/views/#{view_name}/pages/#{page}.lt3", "")
          end
        end
      else
        puts "[WIZARD] User chose to create empty files for all missing pages"
        # Create empty .lt3 files for all missing pages
        missing_pages.each do |page|
          puts "[WIZARD] Creating empty file for page: #{page}"
          write_file("#{@repo.root}/views/#{view_name}/pages/#{page}.lt3", "")
        end
      end
    else
      puts "[WIZARD] No missing pages found"
    end
  end

  def yesno(question)
    print "#{question} (y/n): "
    response = get_string&.downcase
    log("YESNO: question='#{question}'\n       response='#{response}'")
    response == "y" || response == "yes"
  end

  def get_string
    if STDIN.tty?
      result = Readline.readline
      log("GET_STRING: TTY mode, result=#{result.inspect}")
      result
    else
      result = gets&.chomp&.strip
      log("GET_STRING: Non-TTY mode, result=#{result.inspect}")
      result
    end
  end

  def mainloop
    loop do
      begin
        current_view = @repo.current_view
        current_view_name = current_view&.name || "no-view"
        prompt = "[#{current_view_name}] "
        
        # Use regular gets for automated tests, Readline for interactive
        if STDIN.tty?
          input = Readline.readline(prompt, true)
        else
          print prompt
          input = gets&.chomp&.strip
        end

        break if input.nil? || input.downcase == "quit" || input.downcase == "q"

        next if input.empty?

        execute_command(input)
      rescue Interrupt
        puts "\nUse 'quit' to exit"
      rescue => e
        puts "Error: #{e.message}"
        puts e.backtrace.first if @testing
      end
    end

    puts
    puts "  Goodbye!"
    puts
  end

  private

  def setup_readline
    # Set up tab completion
    Readline.completion_proc = proc do |input|
      completions = []
      
      # Split input to get command and arguments
      parts = input.split(/\s+/)
      command = parts[0]&.downcase
      args = parts[1..-1] || []
      
      if args.empty?
        # Complete command names
        commands = %w[view change list create version help quit cv lsv v h q]
        completions = commands.select { |cmd| cmd.start_with?(command || "") }
      elsif command == "change" || command == "cv"
        # Complete view names
        if @repo
          view_names = @repo.views.map(&:name)
          completions = view_names.select { |name| name.start_with?(args.last || "") }
        end
      elsif command == "list" && args.length == 1 && args[0] == "views"
        # Complete "list views" command
        completions = []
      elsif command == "create" && args.length == 1 && args[0] == "view"
        # Suggest common view names for create view
        suggestions = %w[blog personal work tech travel]
        completions = suggestions
      end
      
      completions
    end
  end

  def create_test_repo
    puts "Creating test repository..."
    @testing = true
    @repo = Scriptorium::Repo.create("scriptorium-TEST", testmode: true)
    puts "Test repository created successfully!"
  end

  private def execute_command(input)
    parts = input.split(/\s+/, 2)
    cmd = parts[0].downcase
    args = parts[1] || ""

    # Handle multi-word commands first
    if cmd == "list" && args.start_with?("views")
      list_views
    elsif cmd == "list" && args.start_with?("posts")
      list_posts
    elsif cmd == "list" && args.start_with?("drafts")
      list_drafts
    elsif cmd == "change" && args.start_with?("view")
      change_view(args)
    elsif cmd == "create" && args.start_with?("view")
      create_view(args)
    elsif cmd == "create" && args.start_with?("draft")
      create_draft(args)
    elsif cmd == "create" && args.start_with?("post")
      create_post(args)

    else
      # Handle single-word commands
      case cmd
      when "help", "h"
        show_help
      when "view"
        show_current_view
      when "cv"
        change_view(args)
      when "lsv"
        list_views
      when "lsp"
        list_posts
      when "lsd"
        list_drafts
      when "cd"
        create_draft("draft")
      when "cp"
        create_post("post")
      when "version", "v"
        show_version
      when "quit", "q"
        exit 0
      else
        puts
        puts "  Unknown command: #{cmd}. Type 'help' for available commands."
        puts
      end
    end
  end

  private def show_help
    puts
    puts <<~HELP
      Available commands:
      
      View Management:
        view                   - Show current view
        change view [<name>]   (cv) - Switch to a view
        list views             (lsv) - List all views
        create view [<name> <title>] - Create a new view
      
      Content:
        list posts             (lsp) - List posts in current view
        list drafts            (lsd) - List all drafts
        create draft [<title>] (cd)  - Create a new draft
        create post [<title>]  (cp)  - Create draft, edit, and convert to post

      
      Other:
        version                (v)  - Show version
        help                   (h)  - Show this help
        quit                   (q)  - Exit
    HELP
    puts
  end

  private def show_current_view
    current_view = @repo.current_view
    current_view_name = current_view&.name || "none"
    puts
    puts "  Current view: #{current_view_name}"
    puts
  end

  private def change_view(args)
    # Handle "change view <name>" format
    if args == "view" || args.start_with?("view ")
      # Remove "view " prefix if present, otherwise args is just "view"
      view_name = args == "view" ? "" : args[5..-1].strip
    else
      view_name = args.strip
    end
    
    if view_name.empty?
      # Interactive mode - prompt for view name
      puts
      puts "  Available views:"
      views = @repo.views
      if views.empty?
        puts "    No views found"
        puts
        return
      else
        current_view = @repo.current_view
        current_view_name = current_view&.name
        
        views.each do |view|
          current = view.name == current_view_name ? "*" : " "
          puts "    #{current} #{view.name} - #{view.title}"
        end
        puts
      end
      
      print "  Enter view name: "
      view_name = gets&.chomp&.strip
      return if view_name.nil? || view_name.empty?
    end

    view = @repo.lookup_view(view_name)
    @repo.view(view_name)
    puts
    puts "  Switched to view '#{view_name}'"
    puts
  rescue => e
    puts
    puts "  View '#{view_name}' not found"
    puts
  end

  private def create_view(args)
    # Handle "create view" format - prompt for all parameters
    if args == "view" || args.start_with?("view ")
      # Remove "view " prefix if present, otherwise args is just "view"
      view_args = args == "view" ? "" : args[5..-1]
      
      if view_args.strip.empty?
        # Interactive mode - prompt for all parameters
        print "  Enter view name: "
        name = get_string
        return if name.nil? || name.empty?
        
        print "  Enter view title: "
        title = get_string
        return if title.nil? || title.empty?
        
        print "  Enter subtitle (optional): "
        subtitle = get_string
        subtitle = nil if subtitle.empty?
        
        # Create view with all parameters
        @repo.create_view(name, title, subtitle, theme: "standard")
        puts
        puts "  Created view '#{name}' with title '#{title}'"
        puts "  Switched to view '#{name}'"
        puts
      else
        # Legacy mode - still support "create view <name> <title>"
        parts = view_args.split(/\s+/, 2)
        if parts.length < 2
          puts
          puts "  Usage: create view [<name> <title>]"
          puts
          return
        end

        name, title = parts
        
        # Prompt for subtitle
        print "  Enter subtitle (optional): "
        subtitle = get_string
        subtitle = nil if subtitle.empty?
        
        # Create view with all parameters
        @repo.create_view(name, title, subtitle, theme: "standard")
        puts
        puts "  Created view '#{name}' with title '#{title}'"
        puts "  Switched to view '#{name}'"
        puts
      end
    else
      puts
      puts "  Usage: create view [<name> <title>]"
      puts
    end
  end

  private def create_draft(args)
    # Handle "create draft" format - prompt for all parameters
    if args == "draft" || args.start_with?("draft ")
      # Remove "draft " prefix if present, otherwise args is just "draft"
      draft_args = args == "draft" ? "" : args[6..-1]
      
      if draft_args.strip.empty?
        # Interactive mode - prompt for all parameters
        print "  Enter draft title: "
        title = gets&.chomp&.strip
        return if title.nil? || title.empty?
        
        print "  Enter draft body: "
        body = gets&.chomp&.strip
        return if body.nil? || body.empty?
        
        print "  Enter tags (optional, comma-separated): "
        tags_input = gets&.chomp&.strip
        tags = tags_input.empty? ? nil : tags_input.split(",").map(&:strip)
        
        print "  Enter blurb (optional): "
        blurb = gets&.chomp&.strip
        blurb = nil if blurb.empty?
        
        # Create draft with all parameters
        draft_path = @repo.create_draft(
          title: title,
          body: body,
          views: @repo.current_view&.name,
          tags: tags,
          blurb: blurb
        )
        puts
        puts "  Created draft: #{draft_path}"
        puts
      else
        # Legacy mode - still support "create draft <title>"
        title = draft_args.strip
        
        print "  Enter draft body: "
        body = gets&.chomp&.strip
        return if body.nil? || body.empty?
        
        print "  Enter tags (optional, comma-separated): "
        tags_input = gets&.chomp&.strip
        tags = tags_input.empty? ? nil : tags_input.split(",").map(&:strip)
        
        print "  Enter blurb (optional): "
        blurb = gets&.chomp&.strip
        blurb = nil if blurb.empty?
        
        # Create draft with all parameters
        draft_path = @repo.create_draft(
          title: title,
          body: body,
          views: @repo.current_view&.name,
          tags: tags,
          blurb: blurb
        )
        puts
        puts "  Created draft: #{draft_path}"
        puts
      end
    else
      puts
      puts "  Usage: create draft [<title>]"
      puts
    end
  end

  def show_version
    puts
    puts "  Scriptorium #{Scriptorium::VERSION}"
    puts
  end

  def get_started
    puts
    puts "  === Scriptorium Setup ==="
    puts
    
    puts "  No editor configured. Let's set one up."
    pick_editor
    
    puts
    puts "  Setup complete!"
    puts "  You can now use 'create post <title>' to create posts with your editor."
    puts
  end

  def pick_editor
    puts
    puts "  Available editors:"
    
    # Check for common editors (prioritized for single file editing)
    editors = []
    %w[nano vim emacs vi micro].each do |editor|
      if which(editor)
        editors << editor
      end
    end
    
    # The original Unix line editor - for the brave souls who want ultimate speed
    if which("ed")
      editors << "ed"
    end
    
    
    if editors.empty?
      puts "    No common editors found. Please install nano, vim, emacs, vi, micro, or ed."
      puts "    You can manually set your editor later by editing config/editor.txt"
      puts
      return
    end
    
    # Show available editors
    editors.each_with_index do |editor, index|
      puts "    #{index + 1}. #{editor}"
    end
    
    # Let user pick
    print "  Choose editor (1-#{editors.length}): "
    choice = get_string
    
    if choice && choice.match?(/^\d+$/) && choice.to_i.between?(1, editors.length)
      selected_editor = editors[choice.to_i - 1]
      
      # Save the choice
      make_dir(@repo.root/"config")
      write_file(@repo.root/"config/editor.txt", selected_editor)
      
      puts
      puts "  Selected editor: #{selected_editor}"
      puts "  Editor preference saved to config/editor.txt"
    else
      puts
      puts "  Invalid choice. Editor not changed."
    end
  end

  def list_views
    puts
    views = @repo.views
    if views.empty?
      puts "  No views found"
    else
      current_view = @repo.current_view
      current_view_name = current_view&.name
      
      views.each do |view|
        current = view.name == current_view_name ? "*" : " "
        puts "    #{current} #{view.name}  #{view.title}"
      end
    end
    puts
  end





  def which(command)
    # Use File.which if available (Ruby 3.2+)
    if File.respond_to?(:which)
      File.which(command)
    else
      # Fall back to system call
      result = `which #{command} 2>/dev/null`.chomp
      result.empty? ? nil : result
    end
  end

  private def create_post(args)
    # Handle "create post <title>" format
    if args == "post" || args.start_with?("post ")
      # Remove "post " prefix if present, otherwise args is just "post"
      post_args = args == "post" ? "" : args[5..-1]
      
      if post_args.strip.empty?
        # Interactive mode - prompt for title
        print "  Enter post title: "
        title = gets&.chomp&.strip
        return if title.nil? || title.empty?
      else
        # Use provided title
        title = post_args.strip
      end
      
      # Check if editor is configured
      editor_file = @repo.root/"config/editor.txt"
      unless File.exist?(editor_file)
        puts
        puts "  No editor configured. Please configure an editor in config/editor.txt"
        puts
        return
      end
      
      editor = read_file(editor_file).strip
      
      # Create draft
      begin
        draft_path = @repo.create_draft(
          title: title,
          body: "",  # Empty body to start
          views: @repo.current_view&.name,
          tags: nil,
          blurb: nil
        )
        
        puts
        puts "  Created draft: #{File.basename(draft_path)}"
        puts "  Opening in #{editor}..."
        puts
        
        # Open in editor
        system("#{editor} #{draft_path}")
        
        puts
        puts "  Converting draft to post..."
        
        # Convert draft to post (like Runeblog)
        begin
          post_num = @repo.finish_draft(draft_path)
          post = @repo.post(post_num)
          if post && post.title
            puts "  Post created: ##{post_num} - #{post.title}"
          else
            puts "  Post created: ##{post_num}"
          end
          puts "  Use 'deploy' to publish to server when ready."
        rescue => e
          puts "  Error converting to post: #{e.message}"
        end
        
        puts
        
      rescue => e
        puts
        puts "  Error creating post: #{e.message}"
        puts
      end
    else
      puts
      puts "  Usage: create post [<title>]"
      puts
    end
  end

  private def list_posts
    current_view = @repo.current_view
    if current_view.nil?
      puts
      puts "  No current view selected"
      puts
      return
    end

    posts = @repo.all_posts(current_view)
    
    puts
    if posts.empty?
      puts "  No posts found in view '#{current_view.name}'"
    else
      puts "  Posts in view '#{current_view.name}':"
      posts.each do |post|
        puts "    #{post.title}"
      end
    end
    puts
  end

  private def list_drafts
    drafts_dir = @repo.root/:drafts
    return unless Dir.exist?(drafts_dir)
    
    draft_files = Dir.glob("#{drafts_dir}/*-draft.lt3")
    
    puts
    if draft_files.empty?
      puts "  No drafts found"
    else
      draft_files.each do |file|
        filename = File.basename(file)
        puts "    #{filename}"
      end
    end
    puts
  end

end

###### Main ######

# Only run main code if this file is executed directly
if __FILE__ == $0
  s = ScriptoriumTUI.new

  # Auto-discovery: check for existing repo
  got_repo = s.discover_repo

  unless got_repo
    s.log("SCRIPT: Creating new repository")
    s.create_new_repo
    ques = "Do you want assistance in creating your first view?"
    s.log("SCRIPT: Asking about wizard: #{ques}")
    if s.yesno(ques)
      s.log("SCRIPT: User chose to run wizard")
      s.wizard_first_view
    else
      s.log("SCRIPT: User chose not to run wizard")
    end
  end

  # Main REPL loop
  s.log("SCRIPT: Starting mainloop")
  s.mainloop
end
