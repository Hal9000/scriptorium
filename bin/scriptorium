#!/Users/Hal/.rbenv/versions/3.2.3/bin/ruby

require_relative "../lib/scriptorium"
require 'readline'

# Main entry point for Scriptorium TUI
class ScriptoriumTUI
  include Scriptorium::Exceptions
  include Scriptorium::Helpers

  def initialize
    @repo = nil
    @testing = false
    setup_readline
  end

  def run
    puts "=== Scriptorium TUI ==="
    puts "Type 'help' for commands, 'quit' to exit"
    puts

    # Auto-discovery: check for existing repo
    discover_repo

    # Main REPL loop
    mainloop
  end

  private

  def setup_readline
    # Set up tab completion
    Readline.completion_proc = proc do |input|
      completions = []
      
      # Split input to get command and arguments
      parts = input.split(/\s+/)
      command = parts[0]&.downcase
      args = parts[1..-1] || []
      
      if args.empty?
        # Complete command names
        commands = %w[view change list create version help quit cv lsv v h q]
        completions = commands.select { |cmd| cmd.start_with?(command || "") }
      elsif command == "change" || command == "cv"
        # Complete view names
        if @repo
          view_names = @repo.views.map(&:name)
          completions = view_names.select { |name| name.start_with?(args.last || "") }
        end
      elsif command == "list" && args.length == 1 && args[0] == "views"
        # Complete "list views" command
        completions = []
      elsif command == "create" && args.length == 1 && args[0] == "view"
        # Suggest common view names for create view
        suggestions = %w[blog personal work tech travel]
        completions = suggestions
      end
      
      completions
    end
  end

  def discover_repo
    if Dir.exist?("scriptorium-TEST")
              # Check if this is an interactive TTY session
        if STDIN.tty?
          # Interactive session - use a separate repo
          tty_repo_path = "scriptorium-TEST-tty"
          if Dir.exist?(tty_repo_path)
            puts "Found existing interactive test repository: #{tty_repo_path}"
            @testing = true
            @repo = Scriptorium::Repo.open(tty_repo_path)
            puts "Loaded interactive test repository"
          else
            puts "Found existing test repository: scriptorium-TEST"
            puts "Creating interactive test repository: #{tty_repo_path}"
            @testing = true
            @repo = Scriptorium::Repo.create(tty_repo_path)
            puts "Created interactive test repository"
          end
        else
          # Automated test session
          puts "Found existing test repository: scriptorium-TEST"
          @testing = true
          @repo = Scriptorium::Repo.open("scriptorium-TEST")
          puts "Loaded test repository"
        end
    elsif Dir.exist?(".scriptorium")
      puts "Found existing repository: .scriptorium"
      home = ENV['HOME']
      @repo = Scriptorium::Repo.open("#{home}/.scriptorium")
      puts "Loaded repository"
    else
      puts "No repository found."
      if ask_yes_no("Create a new repository?")
        create_new_repo
      else
        puts "Exiting. Create a repository first or run in a directory with one."
        exit 0
      end
    end
    puts
  end

  def create_test_repo
    puts "Creating test repository..."
    @testing = true
    @repo = Scriptorium::Repo.create("scriptorium-TEST")
    puts "Test repository created successfully!"
  end

  def create_new_repo
    puts "Creating new repository..."
    @repo = Scriptorium::Repo.create(".")
    puts "Created repository successfully."
    
    # Run initial setup (like Runeblog)
    get_started
  end

  def mainloop
    loop do
      begin
        current_view = @repo.current_view
        current_view_name = current_view&.name || "no-view"
        prompt = "[#{current_view_name}] "
        
        # Use regular gets for automated tests, Readline for interactive
        if STDIN.tty?
          input = Readline.readline(prompt, true)
        else
          print prompt
          input = gets&.chomp&.strip
        end

        break if input.nil? || input.downcase == "quit" || input.downcase == "q"

        next if input.empty?

        execute_command(input)
      rescue Interrupt
        puts "\nUse 'quit' to exit"
      rescue => e
        puts "Error: #{e.message}"
        puts e.backtrace.first if @testing
      end
    end

    puts
    puts "  Goodbye!"
    puts
  end

  def execute_command(input)
    parts = input.split(/\s+/, 2)
    cmd = parts[0].downcase
    args = parts[1] || ""

    # Handle multi-word commands first
    if cmd == "list" && args.start_with?("views")
      list_views
    elsif cmd == "list" && args.start_with?("posts")
      list_posts
    elsif cmd == "list" && args.start_with?("drafts")
      list_drafts
    elsif cmd == "change" && args.start_with?("view")
      change_view(args)
    elsif cmd == "create" && args.start_with?("view")
      create_view(args)
    elsif cmd == "create" && args.start_with?("draft")
      create_draft(args)
    elsif cmd == "create" && args.start_with?("post")
      create_post(args)

    else
      # Handle single-word commands
      case cmd
      when "help", "h"
        show_help
      when "view"
        show_current_view
      when "cv"
        change_view(args)
      when "lsv"
        list_views
      when "lsp"
        list_posts
      when "lsd"
        list_drafts
      when "cd"
        create_draft("draft")
      when "cp"
        create_post("post")
      when "version", "v"
        show_version
      when "quit", "q"
        exit 0
      else
        puts
        puts "  Unknown command: #{cmd}. Type 'help' for available commands."
        puts
      end
    end
  end

  def show_help
    puts
    puts <<~HELP
      Available commands:
      
      View Management:
        view                   - Show current view
        change view [<name>]   (cv) - Switch to a view
        list views             (lsv) - List all views
        create view [<name> <title>] - Create a new view
      
      Content:
        list posts             (lsp) - List posts in current view
        list drafts            (lsd) - List all drafts
        create draft [<title>] (cd)  - Create a new draft
        create post [<title>]  (cp)  - Create draft, edit, and convert to post

      
      Other:
        version                (v)  - Show version
        help                   (h)  - Show this help
        quit                   (q)  - Exit
    HELP
    puts
  end

  def show_current_view
    current_view = @repo.current_view
    current_view_name = current_view&.name || "none"
    puts
    puts "  Current view: #{current_view_name}"
    puts
  end

  def change_view(args)
    # Handle "change view <name>" format
    if args == "view" || args.start_with?("view ")
      # Remove "view " prefix if present, otherwise args is just "view"
      view_name = args == "view" ? "" : args[5..-1].strip
    else
      view_name = args.strip
    end
    
    if view_name.empty?
      # Interactive mode - prompt for view name
      puts
      puts "  Available views:"
      views = @repo.views
      if views.empty?
        puts "    No views found"
        puts
        return
      else
        current_view = @repo.current_view
        current_view_name = current_view&.name
        
        views.each do |view|
          current = view.name == current_view_name ? "*" : " "
          puts "    #{current} #{view.name} - #{view.title}"
        end
        puts
      end
      
      print "  Enter view name: "
      view_name = gets&.chomp&.strip
      return if view_name.nil? || view_name.empty?
    end

    view = @repo.lookup_view(view_name)
    @repo.view(view_name)
    puts
    puts "  Switched to view '#{view_name}'"
    puts
  rescue => e
    puts
    puts "  View '#{view_name}' not found"
    puts
  end

  def create_view(args)
    # Handle "create view" format - prompt for all parameters
    if args == "view" || args.start_with?("view ")
      # Remove "view " prefix if present, otherwise args is just "view"
      view_args = args == "view" ? "" : args[5..-1]
      
      if view_args.strip.empty?
        # Interactive mode - prompt for all parameters
        print "  Enter view name: "
        name = gets&.chomp&.strip
        return if name.nil? || name.empty?
        
        print "  Enter view title: "
        title = gets&.chomp&.strip
        return if title.nil? || title.empty?
        
        print "  Enter subtitle (optional): "
        subtitle = gets&.chomp&.strip
        subtitle = nil if subtitle.empty?
        
        # Create view with all parameters
        @repo.create_view(name, title, subtitle, theme: "standard")
        puts
        puts "  Created view '#{name}' with title '#{title}'"
        puts "  Switched to view '#{name}'"
        puts
      else
        # Legacy mode - still support "create view <name> <title>"
        parts = view_args.split(/\s+/, 2)
        if parts.length < 2
          puts
          puts "  Usage: create view [<name> <title>]"
          puts
          return
        end

        name, title = parts
        
        # Prompt for subtitle
        print "  Enter subtitle (optional): "
        subtitle = gets&.chomp&.strip
        subtitle = nil if subtitle.empty?
        
        # Create view with all parameters
        @repo.create_view(name, title, subtitle, theme: "standard")
        puts
        puts "  Created view '#{name}' with title '#{title}'"
        puts "  Switched to view '#{name}'"
        puts
      end
    else
      puts
      puts "  Usage: create view [<name> <title>]"
      puts
    end
  end

  def create_draft(args)
    # Handle "create draft" format - prompt for all parameters
    if args == "draft" || args.start_with?("draft ")
      # Remove "draft " prefix if present, otherwise args is just "draft"
      draft_args = args == "draft" ? "" : args[6..-1]
      
      if draft_args.strip.empty?
        # Interactive mode - prompt for all parameters
        print "  Enter draft title: "
        title = gets&.chomp&.strip
        return if title.nil? || title.empty?
        
        print "  Enter draft body: "
        body = gets&.chomp&.strip
        return if body.nil? || body.empty?
        
        print "  Enter tags (optional, comma-separated): "
        tags_input = gets&.chomp&.strip
        tags = tags_input.empty? ? nil : tags_input.split(",").map(&:strip)
        
        print "  Enter blurb (optional): "
        blurb = gets&.chomp&.strip
        blurb = nil if blurb.empty?
        
        # Create draft with all parameters
        draft_path = @repo.create_draft(
          title: title,
          body: body,
          views: @repo.current_view&.name,
          tags: tags,
          blurb: blurb
        )
        puts
        puts "  Created draft: #{draft_path}"
        puts
      else
        # Legacy mode - still support "create draft <title>"
        title = draft_args.strip
        
        print "  Enter draft body: "
        body = gets&.chomp&.strip
        return if body.nil? || body.empty?
        
        print "  Enter tags (optional, comma-separated): "
        tags_input = gets&.chomp&.strip
        tags = tags_input.empty? ? nil : tags_input.split(",").map(&:strip)
        
        print "  Enter blurb (optional): "
        blurb = gets&.chomp&.strip
        blurb = nil if blurb.empty?
        
        # Create draft with all parameters
        draft_path = @repo.create_draft(
          title: title,
          body: body,
          views: @repo.current_view&.name,
          tags: tags,
          blurb: blurb
        )
        puts
        puts "  Created draft: #{draft_path}"
        puts
      end
    else
      puts
      puts "  Usage: create draft [<title>]"
      puts
    end
  end

  def show_version
    puts
    puts "  Scriptorium #{Scriptorium::VERSION}"
    puts
  end

  def get_started
    puts
    puts "  === Scriptorium Setup ==="
    puts
    
    puts "  No editor configured. Let's set one up."
    pick_editor
    
    puts
    puts "  Setup complete!"
    puts "  You can now use 'create post <title>' to create posts with your editor."
    puts
  end

  def pick_editor
    puts
    puts "  Available editors:"
    
    # Check for common editors (prioritized for single file editing)
    editors = []
    %w[nano vim emacs vi micro subl].each do |editor|
      if which(editor)
        editors << editor
      end
    end
    
    # The original Unix line editor - for the brave souls who want ultimate speed
    if which("ed")
      editors << "ed"
    end
    
    # Check for Sublime Text in Applications (macOS)
    subl_path = "/Applications/Sublime Text.app/Contents/SharedSupport/bin/subl"
    if File.exist?(subl_path) && !editors.include?("subl")
      editors << "subl"
    end
    

    
    if editors.empty?
      puts "    No common editors found. Please install nano, vim, emacs, vi, micro, or ed."
      puts "    You can manually set your editor later by editing config/editor.txt"
      puts
      return
    end
    
    # Show available editors
    editors.each_with_index do |editor, index|
      puts "    #{index + 1}. #{editor}"
    end
    
    # Let user pick
    print "  Choose editor (1-#{editors.length}): "
    choice = gets&.chomp&.strip
    
    if choice && choice.match?(/^\d+$/) && choice.to_i.between?(1, editors.length)
      selected_editor = editors[choice.to_i - 1]
      
      # Save the choice
      make_dir(@repo.root/"config")
      write_file(@repo.root/"config/editor.txt", selected_editor)
      
      puts
      puts "  Selected editor: #{selected_editor}"
      puts "  Editor preference saved to config/editor.txt"
    else
      puts
      puts "  Invalid choice. Editor not changed."
    end
  end

  def list_views
    puts
    views = @repo.views
    if views.empty?
      puts "  No views found"
    else
      current_view = @repo.current_view
      current_view_name = current_view&.name
      
      views.each do |view|
        current = view.name == current_view_name ? "*" : " "
        puts "    #{current} #{view.name}  #{view.title}"
      end
    end
    puts
  end

  def ask_yes_no(question)
    print "#{question} (y/n): "
    response = gets&.chomp&.downcase
    response == "y" || response == "yes"
  end

  def which(command)
    # Use File.which if available (Ruby 3.2+)
    if File.respond_to?(:which)
      File.which(command)
    else
      # Fall back to system call
      result = `which #{command} 2>/dev/null`.chomp
      result.empty? ? nil : result
    end
  end

  def create_post(args)
    # Handle "create post <title>" format
    if args == "post" || args.start_with?("post ")
      # Remove "post " prefix if present, otherwise args is just "post"
      post_args = args == "post" ? "" : args[5..-1]
      
      if post_args.strip.empty?
        # Interactive mode - prompt for title
        print "  Enter post title: "
        title = gets&.chomp&.strip
        return if title.nil? || title.empty?
      else
        # Use provided title
        title = post_args.strip
      end
      
      # Check if editor is configured
      editor_file = @repo.root/"config/editor.txt"
      unless File.exist?(editor_file)
        puts
        puts "  No editor configured. Please configure an editor in config/editor.txt"
        puts
        return
      end
      
      editor = read_file(editor_file).strip
      
      # Create draft
      begin
        draft_path = @repo.create_draft(
          title: title,
          body: "",  # Empty body to start
          views: @repo.current_view&.name,
          tags: nil,
          blurb: nil
        )
        
        puts
        puts "  Created draft: #{File.basename(draft_path)}"
        puts "  Opening in #{editor}..."
        puts
        
        # Open in editor
        system("#{editor} #{draft_path}")
        
        puts
        puts "  Converting draft to post..."
        
        # Convert draft to post (like Runeblog)
        begin
          post_num = @repo.finish_draft(draft_path)
          post = @repo.post(post_num)
          if post && post.title
            puts "  Post created: ##{post_num} - #{post.title}"
          else
            puts "  Post created: ##{post_num}"
          end
          puts "  Use 'deploy' to publish to server when ready."
        rescue => e
          puts "  Error converting to post: #{e.message}"
        end
        
        puts
        
      rescue => e
        puts
        puts "  Error creating post: #{e.message}"
        puts
      end
    else
      puts
      puts "  Usage: create post [<title>]"
      puts
    end
  end

  def list_posts
    current_view = @repo.current_view
    if current_view.nil?
      puts
      puts "  No current view selected"
      puts
      return
    end

    posts = @repo.all_posts(current_view)
    
    puts
    if posts.empty?
      puts "  No posts found in view '#{current_view.name}'"
    else
      puts "  Posts in view '#{current_view.name}':"
      posts.each do |post|
        puts "    #{post.title}"
      end
    end
    puts
  end

  def list_drafts
    drafts_dir = @repo.root/:drafts
    return unless Dir.exist?(drafts_dir)
    
    draft_files = Dir.glob("#{drafts_dir}/*-draft.lt3")
    
    puts
    if draft_files.empty?
      puts "  No drafts found"
    else
      puts "  Drafts:"
      draft_files.each do |file|
        filename = File.basename(file)
        puts "    #{filename}"
      end
    end
    puts
  end
end

# Run the TUI if this file is executed directly
if __FILE__ == $0
  ScriptoriumTUI.new.run
end 